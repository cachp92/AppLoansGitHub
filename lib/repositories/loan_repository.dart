import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/loan.dart';
import '../services/amortization_service.dart';

class LoanRepository extends ChangeNotifier {
  final List<Loan> _loans = [];
  final AmortizationService _amortizationService;
  StreamSubscription<QuerySnapshot>? _subscription;
  final CollectionReference _collection = FirebaseFirestore.instance.collection('loans');

  LoanRepository(this._amortizationService) {
    _init();
  }

  void _init() {
    _subscription = _collection.snapshots().listen((snapshot) {
      _loans.clear();
      for (var doc in snapshot.docs) {
        try {
          // Use ID from document if not in map, though fromMap handles it if passed
          _loans.add(Loan.fromMap(doc.data() as Map<String, dynamic>, id: doc.id));
        } catch (e) {
          debugPrint('Error parsing loan ${doc.id}: $e');
        }
      }
      notifyListeners();
      
      // Seed if empty and this was the initial load? 
      // Need to be careful not to seed if user deleted all. 
      // But requirement says: "Only seed demo loans if Firestore collection is empty."
      // We can check this once on startup. 
      // But init runs on subscription. 
      // Let's rely on manual reset or one-time check? 
      // If we check here, every time it empties, it might re-seed unless we flag it.
      // Better to check once? 
      // For now, let's just listen. Seeding can be manual or checked in constructor separately.
      // Refactored logic: Constructor -> Listen. 
      // The requirement says: "Only seed demo loans if ... empty". 
      // Let's do a one-time check.
    });
    
    // One-time check for seeding
    _checkAndSeed();
  }
  
  Future<void> _checkAndSeed() async {
    final snapshot = await _collection.get();
    if (snapshot.docs.isEmpty) {
      _seedDemoData();
    }
  }

  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }

  List<Loan> get loans => List.unmodifiable(_loans);

  Future<void> _seedDemoData() async {
    final now = DateTime.now();
    final demoLoans = [
      Loan(name: 'Personal Loan', type: LoanType.personal, currency: Currency.mxn, principal: 50000, annualRate: 15, termMonths: 24, startDate: now.subtract(const Duration(days: 90))),
      Loan(name: 'Mortgage', type: LoanType.hipotecario, currency: Currency.usd, principal: 250000, annualRate: 4.5, termMonths: 240, startDate: DateTime(2020, 1, 15)),
      Loan(name: 'Hybrid Car', type: LoanType.auto, currency: Currency.mxn, principal: 350000, annualRate: 11.9, termMonths: 48, startDate: now),
      Loan(name: 'Visa Credit', type: LoanType.creditCard, currency: Currency.usd, principal: 2000, annualRate: 18, termMonths: 12, startDate: now.subtract(const Duration(days: 30))),
    ];

    final batch = FirebaseFirestore.instance.batch();
    for (var loan in demoLoans) {
      final docRef = _collection.doc(loan.id); // Use the ID generated by Loan constructor
      batch.set(docRef, loan.toMap());
    }
    try {
      await batch.commit();
    } catch (e) {
      debugPrint('Error seeding data: $e');
    }
  }

  Future<void> resetData() async {
    // Wipe and Re-seed
    final batch = FirebaseFirestore.instance.batch();
    final snapshot = await _collection.get();
    for (var doc in snapshot.docs) {
      batch.delete(doc.reference);
    }
    await batch.commit();
    // After delete, subscription updates to empty.
    // Then re-seed.
    await _seedDemoData();
  }

  Future<void> addLoan(Loan loan) async {
    try {
      await _collection.doc(loan.id).set(loan.toMap());
    } catch (e) {
      debugPrint('Error adding loan: $e');
      // Ideally propagate error or show snackbar via callback, 
      // but sticking to repository pattern, we just log unless UI awaits.
      rethrow;
    }
  }
  
  Future<void> updateLoan(Loan updatedLoan) async {
    try {
      await _collection.doc(updatedLoan.id).update(updatedLoan.toMap());
    } catch (e) {
      debugPrint('Error updating loan: $e');
      rethrow; 
    }
  }

  Future<void> deleteLoan(String id) async {
    try {
      await _collection.doc(id).delete();
    } catch (e) {
      debugPrint('Error deleting loan: $e');
      rethrow;
    }
  }

  // Dashboard Totals
  int get totalLoansCount => _loans.length;

  double get totalBalance {
    double sum = 0;
    for (var loan in _loans) {
      // Current balance is technically Amortization based on current date vs start date.
      // MVP simplification: Show initial principal sum OR "Current Outstanding Balance".
      // Let's do Outstanding Balance based on Amortization if possible, 
      // but "Simplicity" + "No Date Logic Complexity" suggests maybe just Principal for now?
      // User request: "Saldo total (suma de saldos actuales)". 
      // Since time doesn't pass in a real-time simulation easily without current date logic,
      // let's assume "Start Date" implies we might be at period 0 or we calculate strict balance.
      // For MVP V0.1: Let's simpler sum the initial principals for now OR 
      // calculate balance if start date is in past.
      
      // Better approach for strict MVP manual test: Calculate amortization table and take the balance 
      // corresponding to "now". If now < start, balance = principal.
      
      sum += _calculateCurrentBalance(loan);
    }
    return sum;
  }

  double get totalMonthlyPayment {
    double sum = 0;
    for (var loan in _loans) {
      var table = _amortizationService.calculateAmortization(loan);
      if (table.isNotEmpty) {
        sum += table.first.payment; // Fixed payment (approx)
      }
    }
    return sum;
  }

  double _calculateCurrentBalance(Loan loan) {
    if (loan.principal <= 0) return 0.0;
    
    // Calculate months elapsed since start date
    final elapsed = getMonthsElapsed(loan);
    
    // If loan is new (0 months or negative), balance is principal
    if (elapsed <= 0) return loan.principal;

    // Use calculateWithExtras to account for any extras (though demo data has none initially)
    // Using calculateWithExtras covers both base and extra scenarios.
    final schedule = _amortizationService.calculateWithExtras(loan);
    
    if (schedule.isEmpty) return loan.principal;

    // If elapsed > term or schedule, returning 0 is handled in getStatus logic 
    // or we can safely return 0 here if index exceeds table.
    if (elapsed >= schedule.length) {
      return schedule.last.balance; // Should be 0 or close to 0
    }

    // Schedule is 1-based period (row 0 is period 1).
    // If elapsed is 1 month, we want balance after payment 1 (index 0).
    return schedule[elapsed - 1].balance;
  }

  // Helpers
  int getMonthsElapsed(Loan loan) {
    final now = DateTime.now();
    return (now.year - loan.startDate.year) * 12 + now.month - loan.startDate.month;
  }

  int getMonthsRemaining(Loan loan) {
    final elapsed = getMonthsElapsed(loan);
    return (loan.termMonths - elapsed) < 0 ? 0 : (loan.termMonths - elapsed);
  }

  double getMonthlyPayment(Loan loan) {
    final schedule = _amortizationService.calculateAmortization(loan);
    return schedule.isNotEmpty ? schedule.first.payment : 0.0;
  }

  double getCurrentBalance(Loan loan) {
     final elapsed = getMonthsElapsed(loan);
     if (elapsed >= loan.termMonths) return 0.0;
     return _calculateCurrentBalance(loan);
  }

  String getStatus(Loan loan) {
    final elapsed = getMonthsElapsed(loan);
    final balance = getCurrentBalance(loan); // Will be 0 if elapsed >= term
    // Status Logic: Paid Off if time up OR balance 0
    if (elapsed >= loan.termMonths || balance <= 0.01) {
      return 'Paid Off';
    }
    return 'Active';
  }

  double getPaidProgress(Loan loan) {
    if (loan.principal == 0) return 1.0;
    final balance = getCurrentBalance(loan);
    return (loan.principal - balance) / loan.principal;
  }
}
